# The Case for Flux

[原文](https://medium.com/swlh/the-case-for-flux-379b7d1982c6)

## 主旨

Flux 解决了什么问题，为什么要使用 Flux

> You Might Need Flux…

### … if your data changes over time

> Remember, the very point of Flux is to make data changes easy to reason about. (Bonus points if changes need to be persisted somewhere, for example to your server.)

> Another important point I want to stress is that you don’t need Flux if you don’t care about immediately reflecting changes in the UI. If you’re okay with data appearing out of sync until the next refresh, stay with the tools and patterns you already know and like.

如果你的数据一直在改变，那么 Flux 可以帮助你找到数据变化的原因，而且还可以保证数据一致性

### … if you want to cache data in memory, but it can change while cached

> This calls for a global entity cache and caching IDs of items on the page instead of the actual JSON from server.

> If you’re using Backbone collections, you have to jump through insane hoops at this point because they will try to create model objects for each server response, but you want them to reuse (and potentially update) objects from the cache. It’s doable but gets ugly soon.

如果你想要缓存你的数据，同时这些缓存的数据还会变化。这里说的是 Flux 不仅可以缓存你的数据，而且可以按照特定的格式保存。在更新数据时，同一份数据只需要更新一次。

### … if your data is relational and models include and depend on each other

> We can implement this as a method on a model, but this means one of them will be managed by another one, as in user.followUser(otherUser). Such indirection makes bugs trickier to track, and it only gets worse if entities of different types need to be updated and rolled back together.

> Either way, at this point your day job is solely fighting with Backbone.

> You’ll need to go out of your way to implement this if your model framework doesn’t already support this out of the box.

如果有些数据是相互关联的，那么可能会造成不同 model 之间耦合。Flux 可以做到各个 model 之间解耦，实现事务操作变得更容易。

### … if the same data is assembled from different sources and can be rendered in several places throughout the UI

> It would be nice if those two lists corresponded to the same model collection, but this means the same model collection needs to be fed from two different API responses. Turns out, 1:1 correspondence between API responses and model objects doesn’t scale! How do you like this, Backbone?

如果相同的数据是从不同的数据源组合而成，并且要在 UI 中多个地方渲染。这里主要是吐槽了 backbone，一个 api response 对应一个 model，这种做法不易扩展。

### The Flux solution: No fat models, separate writing and reading as it gets more sophisticated

> There is a simple solution to these problems: don’t use fat models. Let them be plain objects and don’t try to shoehorn data reading and aggregation into them.

Flux 的做法是摒弃充血的 model 层，只用一些普通的对象。不要把读写逻辑硬塞进去。

> Another important lesson is that data from server is not your model. It serves as yet another input, but it can’t be the primary model, just like it’s hard to express complex domain level logic with classes generated by an ORM.

来自服务器的数据并不是你的 model，只是另一个输入。

> Flux isolates all data mutations to a particular layer in the application and establishes a completely predictable way to get data in and out of there.

Flux 将数据改动操作封装到了单独一层中。这种架构称为：CQRS
![CQRS](https://miro.medium.com/max/1274/1*BtKHcOU1os5CbasqrMECbw.png)

> Caching, invalidation, optimistic updates, aggregation, pagination and a lot of other things get much easier when models are plain objects and don’t try to manage complex updates of each other.

很多事情都会因此变得简单。

> Flux requires you to write more boilerplate code, but in return it makes it easy to reason about complex data changes, and opens up a lot of possibilities impossible with classic MVC, such as recording and replaying UI state just by re-dispatching serialized actions.

> Flux also frees you from the limitations of a particular MVC implementation because you manage your own data.

Flux 要求你写很多模板代码，但是这会让你很容易理清复杂的数据变化，还可以实现那些经典的 MVC 方案很难实现的功能，记录和重放 UI 的状态。  
Flux 也让你脱离某些 MVC 实现方案的局限性，毕竟你可以管理你的数据。

> If your app doesn’t have complex data changes and caching, don’t use it.
> But if it does, I strongly recommend you try Flux.

如果你的应用没有复杂的数据变化，也不需要缓存，那就别用 Flux。否则，我墙裂推荐你使用 Flux。
