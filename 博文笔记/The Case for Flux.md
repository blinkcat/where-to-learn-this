# The Case for Flux

[原文](https://medium.com/swlh/the-case-for-flux-379b7d1982c6)

## 主旨

Flux 解决了什么问题，为什么要使用 Flux

> You Might Need Flux…

### … if your data changes over time

> Remember, the very point of Flux is to make data changes easy to reason about. (Bonus points if changes need to be persisted somewhere, for example to your server.)

> Another important point I want to stress is that you don’t need Flux if you don’t care about immediately reflecting changes in the UI. If you’re okay with data appearing out of sync until the next refresh, stay with the tools and patterns you already know and like.

如果你的数据一直在改变，Flux 可以帮助追踪数据变化，保证数据一致性

### … if you want to cache data in memory, but it can change while cached

> This calls for a global entity cache and caching IDs of items on the page instead of the actual JSON from server.

> If you’re using Backbone collections, you have to jump through insane hoops at this point because they will try to create model objects for each server response, but you want them to reuse (and potentially update) objects from the cache. It’s doable but gets ugly soon.

如果你想要缓存你的数据，同时这些缓存的数据还会变化。这里说的是 Flux 不仅可以缓存你的数据，而且可以按照一定的格式保存。在更新数据时,只需要更新一处。

### … if your data is relational and models include and depend on each other

> We can implement this as a method on a model, but this means one of them will be managed by another one, as in user.followUser(otherUser). Such indirection makes bugs trickier to track, and it only gets worse if entities of different types need to be updated and rolled back together.

> Either way, at this point your day job is solely fighting with Backbone.

> You’ll need to go out of your way to implement this if your model framework doesn’t already support this out of the box.

这里说的是如果有些数据是相关的，那么会造成不同 model 之间耦合。Flux 可以做到各个 model 之间解耦。实现事务操作变得更容易。

### … if the same data is assembled from different sources and can be rendered in several places throughout the UI

> It would be nice if those two lists corresponded to the same model collection, but this means the same model collection needs to be fed from two different API responses. Turns out, 1:1 correspondence between API responses and model objects doesn’t scale! How do you like this, Backbone?

如果相同的数据是从不同的数据源组合而成，并且要在不同地方的 UI 中渲染。这里主要是吐槽了 backbone，一个 api response 对应一个 model，这种做法不可扩展。

### The Flux solution: No fat models, separate writing and reading as it gets more sophisticated

> There is a simple solution to these problems: don’t use fat models. Let them be plain objects and don’t try to shoehorn data reading and aggregation into them.

Flux 的做法是摒弃厚厚的 model 层，只用一些普通的对象。也不要把读写逻辑硬塞进去。

> Another important lesson is that data from server is not your model. It serves as yet another input, but it can’t be the primary model, just like it’s hard to express complex domain level logic with classes generated by an ORM.

来自服务器的数据并不是你的 model，只是另一个输入。

> Flux isolates all data mutations to a particular layer in the application and establishes a completely predictable way to get data in and out of there.

Flux 将数据改动操作封装到了单独一层中。这种架构成为：CQRS
![CQRS](https://miro.medium.com/max/1274/1*BtKHcOU1os5CbasqrMECbw.png)
